/*
 * Jexl
 * Copyright 2020 Tom Shawver
 */

import * as handlers from './handlers.ts'

import type { AstNode } from '../types.ts'

interface Grammar {
  elements: Record<string, any>
  [key: string]: any
}

/**
 * The Evaluator takes a Jexl expression tree as generated by the
 * {@link Parser} and calculates its value within a given context. The
 * collection of transforms, context, and a relative context to be used as the
 * root for relative identifiers, are all specific to an Evaluator instance.
 * When any of these things change, a new instance is required.  However, a
 * single instance can be used to simultaneously evaluate many different
 * expressions, and does not have to be reinstantiated for each.
 * @param {{}} grammar A grammar object against which to evaluate the expression
 *      tree
 * @param {{}} [context] A map of variable keys to their values. This will be
 *      accessed to resolve the value of each non-relative identifier.
 * @param {{}|Array<{}|Array>} [relativeContext] A map or array to be accessed
 *      to resolve the value of a relative identifier.
 */
class Evaluator {
  _grammar: Grammar
  _context: any
  _relContext: any

  constructor(grammar: Grammar, context?: any, relativeContext?: any) {
    this._grammar = grammar
    this._context = context || {}
    this._relContext = relativeContext || this._context
  }

  /**
   * Evaluates an expression tree within the configured context.
   * @param {{}} ast An expression tree object
   * @returns {*} the resulting value of the expression.
   */
  eval(ast: AstNode) {
    return (handlers as any)[ast.type].call(this, ast)
  }

  /**
   * Evaluates each expression within an array, and delivers the response as an
   * array with the resulting values at the same indexes as their originating
   * expressions.
   * @param {Array<string>} arr An array of expression strings to be evaluated
   * @returns {Array<{}>} the result array
   */
  evalArray(arr: AstNode[]) {
    return arr.map((elem: AstNode) => this.eval(elem))
  }

  /**
   * Evaluates each expression within a map, and delivers the response as a map
   * with the same keys, but with the evaluated result for each as their value.
   * @param {{}} map A map of expression names to expression trees to be
   *      evaluated
   * @returns {{}} the result map.
   */
  evalMap(map: Record<string, AstNode>) {
    const entries = Object.entries(map)
    const vals = entries.map(([_, ast]) => this.eval(ast))
    return Object.fromEntries(entries.map(([key], idx) => [key, vals[idx]]))
  }
}

export default Evaluator
